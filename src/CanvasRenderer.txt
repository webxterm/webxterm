import {Terminal} from "./Terminal";
import {
    ATTR_MODE_BOLD,
    // ATTR_MODE_CROSSED_OUT,
    ATTR_MODE_FAINT,
    ATTR_MODE_INVERSE, ATTR_MODE_INVISIBLE, ATTR_MODE_ITALIC,
    ATTR_MODE_NONE,
    // ATTR_MODE_RAPID_BLINK,
    ATTR_MODE_SLOW_BLINK, ATTR_MODE_UNDERLINE,
} from "./buffer/DataBlockAttribute";
import {Buffer} from "./buffer/Buffer";
import {CommonUtils} from "./common/CommonUtils";
import {CanvasSelection, SelectionPoint, SelectionRange} from "./CanvasSelection";
import {ScrollingRegion} from "./ScrollingRegion";
import {LineBuffer} from "./buffer/LineBuffer";




/**
 * 使用Canvas渲染的渲染器
 */
export class CanvasTextRenderer extends CanvasRenderer {




    /**
     * 选择器渲染的块，用于后面抹除已经渲染的区域。
     * item = startPX,width
     */
    private readonly selection_rendered_lines_rect: string[][] = [];

    // 刷新定时器
    private flushTimer: number = 0;

    constructor(terminal: Terminal) {
        super(terminal);
        this.textViewContext = this._term.textView.getContext("2d");
        // this.selectionViewContext = this._term.selectionView.getContext("2d");
        // this.cursorViewContext = this._term.cursorView.getContext("2d");
        // 初始化快照信息
        this.rendered_lines_rect = Array.from({length: this._term.rows}, () => []);
    }

    init(){


        // 更新字体大小，并计算字符宽度
        this.updateFontSize();

    }


    get measuredTextWidth(): number {
        return this._measuredTextWidth;
    }

    /**
     * 获取一行的高度
     */
    get height(): number{
        return this._term.charHeight * this._term.preferences.canvasSizeMultiple;
    }


    /**
     * 更新字体大小并获取字符宽度
     */
    updateFontSize(){

        // 字体大小
        const fontSize = this._term.preferences.fontSize.toLowerCase();
        console.info("CanvasRenderer......updateFontSize()...." + fontSize);

        let fs: number = 0;
        if(fontSize.indexOf("px") != -1){
            fs = parseInt(fontSize);
        } else if(fontSize.indexOf("pt") != -1){
            fs = parseInt(fontSize) / 0.75;
        }
        this.fontSize = fs * 2;
        // 获取默认字体
        if(this.textViewContext) {
            this.updateTextViewFont(DrawFontStyle.NORMAL);
            this.textViewContext.textBaseline = "bottom";
            this._measuredTextWidth = Math.round(this.textViewContext.measureText("w").width);
        }

        if(this.selectionViewContext) {
            this.updateSelectionViewFont(DrawFontStyle.NORMAL)
            this.selectionViewContext.textBaseline = "bottom";
        }
        if(this.cursorViewContext) {
            this.updateCursorViewFont(DrawFontStyle.NORMAL);
            this.cursorViewContext.textBaseline = "bottom";
        }
    }

    /**
     * 更新textView字体
     * @param fontStyle
     */
    updateTextViewFont(fontStyle: DrawFontStyle){
        const font = this.getFont(fontStyle);
        if(this.textViewContext){
            this.textViewContext.font = font;
        }
    }

    /**
     * 更新cursorView字体
     * @param fontStyle
     */
    updateCursorViewFont(fontStyle: DrawFontStyle){
        const font = this.getFont(fontStyle);
        if(this.cursorViewContext){
            this.cursorViewContext.font = font;
        }
    }

    /**
     * 更新selectionView字体
     * @param fontStyle
     */
    updateSelectionViewFont(fontStyle: DrawFontStyle){
        const font = this.getFont(DrawFontStyle.NORMAL);
        if(this.selectionViewContext){
            this.selectionViewContext.font = font;
        }
    }

    // /**
    //  * 获取缓存的行。
    //  */
    // get savedLines(){
    //     return this._term.bufferSet.normal.saved_buf.lines;
    // }


    /**
     * 是否命中当前快照
     */
    isHitCurrentFlushLines(){

        const buffer_size = this.activeBuffer.size;
        let top_index = Math.ceil(this._term.scrollView.scrollTop / this._term.charHeight)
            , bottom_index = top_index + buffer_size - 1;
        if(top_index < 0) top_index = 0;
        return top_index == this._csr.top_index && bottom_index == this._csr.bottom_index;
    }

    /**
     * 获取当前显示的行。
     */
    getCurrentWindowLines(): LineBuffer {

        const saved_buf = this._term.bufferSet.normal.saved_buf
            , saved_size = saved_buf.lines.length
            , saved_max_index = saved_size - 1
            , buffer_size = this.activeBuffer.size;

        let top_index = this._term.getOffsetTop()
            , bottom_index = top_index + buffer_size - 1;

        if(top_index < 0) top_index = 0;

        if(top_index == this._csr.top_index && bottom_index == this._csr.bottom_index){
            return this.activeBuffer.window_buf;
        }

        // 默认
        let window_buf: LineBuffer;

        // 保留区是空的。
        if(saved_size == 0){
            // 显示的所有行都在缓冲区
            window_buf = this.activeBuffer.change_buf;
        } else {
            if(bottom_index <= saved_max_index){
                // 显示的所有行都在保留区、
                window_buf = new LineBuffer(0);
                window_buf.copyFrom(saved_buf, top_index, top_index + buffer_size);
            } else {
                if(saved_max_index <= top_index){
                    // 显示的所有行都在缓冲区
                    window_buf = this.activeBuffer.change_buf;
                } else {
                    // 保留区需要读取的行数
                    const saved_count = saved_max_index - top_index
                        // 缓冲区需要读取的行数
                        , buffer_count = buffer_size - saved_count;

                    window_buf = new LineBuffer(0);
                    if(saved_count > 0) window_buf.copyFrom(saved_buf, top_index, top_index + saved_count);
                    if(buffer_count > 0) window_buf.copyFrom(this.activeBuffer.change_buf, 0, buffer_count);

                }
            }
        }

        this._last_csr.top = this._csr.top;
        this._last_csr.bottom = this._csr.bottom;

        this._csr.top = top_index + 1;
        this._csr.bottom = bottom_index + 1;

        console.info("createSnapshot():_csr:" + JSON.stringify(this._csr) + ', last_csr:' + JSON.stringify(this._last_csr));
        return window_buf;
    }

    get csr(): ScrollingRegion {
        return this._csr;
    }

    /**
     * 更新
     * @param rows
     * @param columns
     */
    resize(rows: number, columns: number){
        // this.startScrollYIndex = undefined;
        // this.stopScrollYIndex = undefined;
        // this.renderedBlocks = [];


        // 更新字体大小，并计算字符宽度
        this.updateFontSize();

        // 重置上次的样色
        this.last_fill_style = "";

        //
        console.info("resize....drawBuffer...");
        this.flushLines(this.getCurrentWindowLines(), false);

        // if(this.activeBuffer) this.drawDefaultBuffer();
    }


    // /**
    //  * 绘制默认缓冲区
    //  */
    // drawFlushLines(){
    //     const t1 = new Date().getTime();
    //     this.drawBuffer(this.getCurrentFlushLines(), false);
    //     console.info("drawDefaultBuffer执行时间：" + (new Date().getTime() - t1))
    // }

    // /**
    //  * 渲染当前Buffer
    //  */
    // drawCurrentSnapshot(){
    //     this.drawBuffer(this.activeBuffer.flushLines, false);
    // }

    /**
     * 渲染当前Buffer
     * @param window_buf 正在显示的行
     * @param fromScrollEvent 是否从滚动的事件渲染
     */
    flushLines(window_buf: LineBuffer, fromScrollEvent: boolean){

        //
        this.activeBuffer.window_buf.removeLine(0, this.activeBuffer.window_buf.lines.length);
        this.activeBuffer.window_buf.copyFrom(window_buf, 0, window_buf.lines.length);

        // 需要重新渲染选择范围
        if(fromScrollEvent){
            const returnCode = this.handleSelect();
            // 0: selection not running
            // 1: select all
            // 2: select
            // 光标渲染
            this.drawCursor();
            if(returnCode == 1) return;
        }

        // console.info("drawBuffer...");

        // if(this.textViewContext){
        //     this.textViewContext.font = this.getFont();
        //     this.textViewContext.fillStyle = this._term.preferences.color;
        // }
        if(this.flushTimer > 0){
            return;
        }

        this.flushTimer = setTimeout(() => {
            for(let i = 0, len = this._term.rows; i < len; i++){
                this.drawLine(i + 1, window_buf);
            }
            // 光标渲染
            this.drawCursor();
            this.flushTimer = 0;

        }, 0);
    }



    //
    // 考虑性能问题，这里采用连加的方式
    // https://www.cnblogs.com/imyeah/p/es6-stringTemplate-performance-testing.html
    getFont(fontStyle: DrawFontStyle){
        const fontName = this._term.preferences.fontFamily.getFontName();
        if(fontStyle == DrawFontStyle.BOTH){
            return "italic bold " + this.fontSize + "px '" + fontName + "'";
        } else {
            if(fontStyle == DrawFontStyle.ITALIC){
                return "italic " + this.fontSize + "px '" + fontName + "'";
            }
            if(fontStyle == DrawFontStyle.BOLD){
                return "bold " + this.fontSize + "px '" + fontName + "'";
            }
            return this.fontSize + "px '" + fontName + "'";
        }
    }


    /**
     * 清除当前行
     * @param y
     */
    clearLine(y: number){
        if(this.textViewContext){
            // 空行不处理。
            const rect = this.rendered_lines_rect[y - 1];
            if(!rect) return;
            const len = rect.length;
            if(len == 0) return;

            const height = this.height, startY = (y - 1) * height;
            for(let i = 0, startX, width; i < len; i++){
                [startX, width] = rect[i].split(",");
                this.textViewContext.clearRect(parseInt(startX), startY, parseInt(width), height);
            }
        }
    }

    /**
     * 清屏
     */
    clearScreen(){
        if(this.textViewContext){
            this.textViewContext.clearRect(0, 0, this._term.textView.width, this._term.textView.height);
        }
    }

    /**
     * 恢复某一行，这个用于联想输入后的。
     */
    restoreDrawLine() {
        // if(this.startScrollYIndex == undefined || this.stopScrollYIndex == undefined) return;
        //
        // const y = this._term.processComposing.anchorY;
        // const array = this.getActiveViewBlocks(this.startScrollYIndex, this.stopScrollYIndex);
        // const rendered = this.renderedBlocks[y - 1] || [];
        // const blocks = array[y - 1];
        // if(rendered.toString() != blocks.toString()){
        //     this.renderedBlocks[y - 1] = this.drawLine(y, blocks);
        // }
        // this.drawLine(y, blocks);
        // this.drawCursor();
    }

    /**
     * 重新渲染正在联想输入的行
     */
    drawComposingLine(){
        /*

        // if(this.startScrollYIndex == undefined || this.stopScrollYIndex == undefined) return;

        let activeComposing = this._term.composing;
        // if(this._term.processComposing.running){
        //     activeComposing = this._term.processComposing;
        // } else if(this._term.composing.running){
        //     activeComposing = this._term.composing;
        // } else {
        //     throw new Error("activeComposing is null");
        // }

        // 当前含有联想输入
        let text = activeComposing.running ? activeComposing.update : activeComposing.end;
        // if(text == "") return;

        const y = activeComposing.anchorY;
        const array: string[][] = [];// this.getActiveViewBlocks(this.startScrollYIndex, this.stopScrollYIndex);
        let blocks = array[y - 1];

        this.clearCursor();
        // 取消选择。
        if(this._term.selection.running) this.unselect(this._term.selection);

        if(this.textViewContext){

            // textBaseline = top: x, y = (左上角X坐标, 左上角Y坐标)
            // textBaseline = bottom: x, y = (左上角X坐标, 左下角Y坐标)
            this.textViewContext.textBaseline = "bottom";
            let width = Math.round(this.textViewContext.measureText("w").width);    // 一个字符的宽度
            // let height = this._term.charHeight * this._term.preferences.canvasSizeMultiple;   // 矩形的高度 = charHeight * 2(画布放大的倍数)
            let startX = 0;                 // 左上角X坐标
            let startY = (y - 1) * this.height;  // 左上角Y坐标
            let textStartY = y * this.height;    // 左下角Y坐标
            blocks = CommonUtils.copyArray(blocks);  // 当前行的所有块
            let charCount = 0;  // 字符计算，主要用于\t(制表符)。

            // 考虑传递的字符含有4字节的字符，如：𠮷😀均为4个字节的长度。 判断一个字符是否为4字节长度的方法是：c.codePointAt(0) > 0xFFFF;
            // https://es6.ruanyifeng.com/#docs/string-methods
            let j = 0,
                count = 0,
                composingStart = this.activeBuffer.x - 1,
                composingStop = composingStart;

            for(let chr of text){
                // 两个字节、四个字节
                if(/[\u4E00-\u9FA5]|[\uFE30-\uFFA0]|[\u3000-\u303F]|[\u2E80-\u2EFF]/gi.test(chr)){
                    // 如果是中文的话，则下一个字符需要填空空格
                    // 格式：内容|len2
                    blocks.splice(composingStart + j, 0,
                        DataBlock.encode(chr, this._term.esParser.attribute, 2));
                    blocks.splice(composingStart + j + 1, 0, Buffer.newEmptyBlock());
                    composingStop += 1;
                    j++;
                } else {
                    blocks.splice(composingStart + j, 0,
                        DataBlock.encode(chr, this._term.esParser.attribute, 1));
                }
                j++;
                count++;
            }

            composingStop += count;

            this.clearLine(y);

            for (let x = 1,
                     len = blocks.length, block: DataBlock ; x <= len; x++) {
                block = DataBlock.decode(blocks[x - 1]);

                // 空块
                if (!block || block.length == 0) {
                    continue;
                }

                // charAt() 不支持4字节字符，如emoji表情
                // let value = block.data,
                //     invisible = block.isInvisible,
                //     underline = block.isUnderline,
                //     len2 = block.displaySize == 2;

                if(!block.isDefaultAttrs){
                    // 没有渲染的块
                    // 解析样式
                    let color = block.colorClass;
                    let bgColor = block.backgroundColorClass;

                    // className:
                    //     "crossed-out",
                    //     "invisible",
                    //     "inverse",
                    //     "rapid-blink",
                    //     "slow-blink",
                    //     "underline",
                    //     "faint",
                    //     "bold"

                    // 字体斜体，字体加粗
                    this.textViewContext.font = this.getFont(block.isItalic, block.isBold);

                    // 背景颜色。
                    if(!!bgColor){
                        if(this._term.preferences.paletteMap[bgColor])
                            bgColor = this._term.preferences.paletteMap[bgColor];
                    }
                    if(!bgColor) bgColor = this._term.preferences.backgroundColor;

                    // 颜色
                    if(!!color && this._term.preferences.paletteMap[color]) color = this._term.preferences.paletteMap[color];
                    if(!color) color = this._term.preferences.color;

                    if(block.isInverse){
                        // 颜色反转
                        let tmpColor = color, tmpBgColor = bgColor;
                        if(!!tmpBgColor) color = tmpBgColor;
                        if(!!tmpColor) bgColor = tmpColor;
                    }

                    if(!!bgColor){
                        this.textViewContext.fillStyle = bgColor;
                        this.textViewContext.fillRect(startX, startY, width * block.displaySize, this.height);
                    }

                    if(!!color){
                        this.textViewContext.fillStyle = color;
                    }

                } else {
                    // 设置默认的字体。
                    this.textViewContext.font = this.getFont();
                    this.textViewContext.fillStyle = this._term.preferences.color;

                }

                // 画下划线，高度为2个像素
                // 如果是联想输入，高度为4个像素。
                if(block.isUnderline || (composingStart < x && x <= composingStop)){
                    let underlineHeight = this._term.preferences.canvasSizeMultiple;
                    underlineHeight *= 2;
                    this.textViewContext.fillRect(startX, textStartY - underlineHeight, width * block.displaySize, underlineHeight);
                }


                // 制表符
                // if(value === "\t"){
                //     const tabSize = this._term.preferences.tabSize;
                //     let spCount = tabSize - (charCount % tabSize);
                //
                //     for(let i = 0; i < spCount; i++){
                //         // 空格不输出，只右移。以减少fillText的调用次数
                //         startX += width;
                //         charCount += 1;
                //     }
                //
                //     continue;
                // }

                // 空格不输出，只右移。以减少fillText的调用次数
                if(!block.isInvisible && block.data != " "){
                    this.textViewContext.fillText(block.data, startX, textStartY);
                }

                startX += width * block.displaySize;
                charCount += block.displaySize;

                if(x == composingStop){
                    if(activeComposing.update.length > 0) {
                        console.info("drawComposingCursor...");
                        this.drawComposingCursor(startX, startY);
                    }
                }

            }

            if(activeComposing.update.length == 0 && this._term.cursor.show){

                this.drawCursor();
            }

            // console.info("startX:" + startX + ",startY: " + startY);

            return blocks;

        }


        return [];*/


        // }

        // this.drawLine(this._term.composing)

        // if(this.textViewContext){

        //     // textBaseline = top: x, y = (左上角X坐标, 左上角Y坐标)
        //     // textBaseline = bottom: x, y = (左上角X坐标, 左下角Y坐标)
        //     this.textViewContext.textBaseline = "bottom";
        //     let width = Math.round(this.textViewContext.measureText("w").width);    // 一个字符的宽度
        //     // let height = this._term.charHeight * this._term.preferences.canvasSizeMultiple;   // 矩形的高度 = charHeight * 2(画布放大的倍数)
        //     let startX = 0;                 // 左上角X坐标
        //     let startY = (y - 1) * this.height;  // 左上角Y坐标
        //     let textStartY = y * this.height;    // 左下角Y坐标
        //     blocks = CommonUtils.copyArray(blocks);  // 当前行的所有块
        //     let charCount = 0;  // 字符计算，主要用于\t(制表符)。
        //
        //     this.clearLine(y);
        //
        //     let composingStart = -1, composingStop = -1; // 联想输入开始和停止的X坐标。
        //     if(composing){
        //         // 当前含有联想输入
        //         let text = composing.running ? composing.update : composing.end;
        //         composingStart = this.activeBuffer.x - 1;
        //         composingStop = composingStart;
        //
        //         // 考虑传递的字符含有4字节的字符，如：𠮷😀均为4个字节的长度。 判断一个字符是否为4字节长度的方法是：c.codePointAt(0) > 0xFFFF;
        //         // https://es6.ruanyifeng.com/#docs/string-methods
        //         let j = 0, count = 0;
        //         for(let chr of text){
        //             // 两个字节、四个字节
        //             if(/[\u4E00-\u9FA5]|[\uFE30-\uFFA0]|[\u3000-\u303F]|[\u2E80-\u2EFF]/gi.test(chr)){
        //                 // 如果是中文的话，则下一个字符需要填空空格
        //                 // 格式：内容|len2
        //                 blocks.splice(composingStart + j, 0,
        //                     DataBlock.encode(chr, this._term.esParser.attribute, 2));
        //                 blocks.splice(composingStart + j + 1, 0, Buffer.newEmptyBlock());
        //                 composingStop += 1;
        //                 j++;
        //             } else {
        //                 blocks.splice(composingStart + j, 0,
        //                     DataBlock.encode(chr, this._term.esParser.attribute, 1));
        //             }
        //             j++;
        //             count++;
        //         }
        //
        //         composingStop += count;
        //
        //         this.clearCursor();
        //
        //         // 取消选择。
        //         if(this._term.selection.running) this.unselect(this._term.selection);
        //     }
        //
        //     for (let x = 1, len = blocks.length, block: DataBlock ; x <= len; x++) {
        //         block = DataBlock.decode(blocks[x - 1]);
        //
        //         // 空块
        //         if (!block || block.length == 0) {
        //             // 联想输入光标制作。
        //             if(composing && x == composingStop){
        //                 // 停止字符后面制作光标。宽度为2.
        //                 if(composing.update.length > 0){
        //                     // 联想输入字符长度大于0
        //                     this.drawComposingCursor(startX, startY);
        //
        //                 } else {
        //                     // 制作普通光标。
        //                     this.drawCursor();
        //                 }
        //             }
        //             continue;
        //         }
        //
        //         // charAt() 不支持4字节字符，如emoji表情
        //         // let value = block.data,
        //         //     invisible = block.isInvisible,
        //         //     underline = block.isUnderline,
        //         //     len2 = block.displaySize == 2;
        //
        //         if(!block.isDefaultAttrs){
        //             // 没有渲染的块
        //             // 解析样式
        //             let color = block.colorClass;
        //             let bgColor = block.backgroundColorClass;
        //
        //             // className:
        //             //     "crossed-out",
        //             //     "invisible",
        //             //     "inverse",
        //             //     "rapid-blink",
        //             //     "slow-blink",
        //             //     "underline",
        //             //     "faint",
        //             //     "bold"
        //
        //             // 字体斜体，字体加粗
        //             this.textViewContext.font = this.getFont(block.isItalic, block.isBold);
        //
        //             // 背景颜色。
        //             if(!!bgColor){
        //                 if(this._term.preferences.paletteMap[bgColor])
        //                     bgColor = this._term.preferences.paletteMap[bgColor];
        //             }
        //             if(!bgColor) bgColor = this._term.preferences.backgroundColor;
        //
        //             // 颜色
        //             if(!!color && this._term.preferences.paletteMap[color]) color = this._term.preferences.paletteMap[color];
        //             if(!color) color = this._term.preferences.color;
        //
        //             if(block.isInverse){
        //                 // 颜色反转
        //                 let tmpColor = color, tmpBgColor = bgColor;
        //                 if(!!tmpBgColor) color = tmpBgColor;
        //                 if(!!tmpColor) bgColor = tmpColor;
        //             }
        //
        //             if(!!bgColor){
        //                 this.textViewContext.fillStyle = bgColor;
        //                 this.textViewContext.fillRect(startX, startY, width * block.displaySize, this.height);
        //             }
        //
        //             if(!!color){
        //                 this.textViewContext.fillStyle = color;
        //             }
        //
        //         } else {
        //             // 设置默认的字体。
        //             this.textViewContext.font = this.getFont();
        //             this.textViewContext.fillStyle = this._term.preferences.color;
        //
        //         }
        //
        //         // 画下划线，高度为2个像素
        //         // 如果是联想输入，高度为4个像素。
        //         if(isDisplayUnderline && (block.isUnderline || (composing && composingStart < x && x <= composingStop))){
        //             let underlineHeight = this._term.preferences.canvasSizeMultiple;
        //             if(composing) underlineHeight *= 2;
        //             this.textViewContext.fillRect(startX, textStartY - underlineHeight, width * block.displaySize, underlineHeight);
        //         }
        //
        //         // 制表符
        //         // if(value === "\t"){
        //         //     const tabSize = this._term.preferences.tabSize;
        //         //     let spCount = tabSize - (charCount % tabSize);
        //         //
        //         //     for(let i = 0; i < spCount; i++){
        //         //         // 空格不输出，只右移。以减少fillText的调用次数
        //         //         startX += width;
        //         //         charCount += 1;
        //         //     }
        //         //
        //         //     continue;
        //         // }
        //
        //         // 空格不输出，只右移。以减少fillText的调用次数
        //         if(!block.isInvisible && block.data != " "){
        //             this.textViewContext.fillText(block.data, startX, textStartY);
        //         }
        //
        //         startX += width * block.displaySize;
        //         charCount += block.displaySize;
        //
        //         // 联想输入光标制作。
        //         if(composing && x == composingStop){
        //             // 停止字符后面制作光标。宽度为2.
        //             if(composing.update.length > 0){
        //                 // 联想输入字符长度大于0
        //                 this.drawComposingCursor(startX, startY);
        //
        //             } else {
        //                 // 制作普通光标。
        //                 this.drawCursor();
        //             }
        //         }
        //
        //
        //     }
        //
        //     return blocks;
        //
        // }
        //
        // return [];

    }

    /**
     * 制作行
     * @param y y坐标，在Canvas可见区域的纵坐标，y的可选值为[1, this.activeBuffer.size]
     * @param window_buf
     */
    drawLine(y: number, window_buf: LineBuffer){

        if(this.textViewContext){

            let startX = 0;                 // 左上角X坐标
            let charCount = 0;  // 字符计算，主要用于\t(制表符)。

            const width = this._measuredTextWidth   // 一个字符的宽度
                , height = this.height // 高度
                , yIndex = y - 1   // 当前的行的索引
                , startY = yIndex * height  // 左上角Y坐标
                , textStartY = y * height   // 左下角Y坐标
                , blocks_data = window_buf.lines[yIndex]    // 数据
                , blocks_attr = window_buf.line_attrs[yIndex]   // 属性
                , blocks_char_width = window_buf.line_char_widths[yIndex]   //
                , blocks_color = window_buf.line_colors[yIndex]
                , blocks_bg_color = window_buf.line_bg_colors[yIndex];

            // 清除之前渲染过的内容
            this.clearLine(y);

            // ['100,100;']
            // 保存渲染信息，为了后面可以快速清除渲染的内容。
            let render_start = -1   // 开始渲染的x
              , render_width = 0;   // 渲染的长度
            const render_info = [];


            for (let x = 0
                     , w: number
                     , displaySize: number
                     , len = this._term.columns
                     , current_font_style: DrawFontStyle = DrawFontStyle.NORMAL
                     , current_fill_style: string = this._term.preferences.color
                     , hasUnderline // 是否含有下划线
                     , isInvisible  // 是否含有下划线
                     , isBold = false
                     , isInverse = false
                     , isFaint = false
                     , isItalic = false
                     , isSlowBlink = false
                     // , isRapidBlink = false
                     // , isCrossedOut = false
                     , attrMode; x < len; x++) {

                // 占位符
                if (!blocks_data[x] || blocks_data[x].length == 0) {
                    continue;
                }

                if(blocks_data[x] == " "){
                    // 空块
                    w = width;
                    displaySize = 1;

                    if(render_start >= 0 && render_width != 0){
                        render_info.push(render_start + "," + render_width);
                        // 空格
                        render_start = -1;
                        render_width = 0;
                    }

                } else {

                    displaySize = blocks_char_width[x];
                    w = width * displaySize;

                    // charAt() 不支持4字节字符，如emoji表情
                    // let value = block.data,
                    //     invisible = block.isInvisible,
                    //     underline = block.isUnderline,
                    //     len2 = block.displaySize == 2;

                    if((attrMode = blocks_attr[x]) != ATTR_MODE_NONE){
                        // 没有渲染的块
                        // 解析样式
                        let color = blocks_color[x];
                        let bgColor = blocks_bg_color[x];

                        // className:
                        //     "crossed-out",
                        //     "invisible",
                        //     "inverse",
                        //     "rapid-blink",
                        //     "slow-blink",
                        //     "underline",
                        //     "faint",
                        //     "bold"
                        if(isBold) isBold = false;
                        if(isInverse) isInverse = false;
                        if(isItalic) isItalic = false;
                        if(isFaint) isFaint = false;
                        if(isFaint) isFaint = false;
                        if(hasUnderline) hasUnderline = false;
                        if(isSlowBlink) isSlowBlink = false;
                        // if(isRapidBlink) isRapidBlink = false;
                        if(isInvisible) isInvisible = false;
                        // if(isCrossedOut) isCrossedOut = false;

                        // 解析attr_mode...
                        switch (attrMode) {
                            case ATTR_MODE_NONE:
                                break;
                            case ATTR_MODE_BOLD:
                                isBold = true;
                                break;
                            case ATTR_MODE_INVERSE:
                                isInverse = true;
                                break;
                            case ATTR_MODE_ITALIC:
                                isItalic = true;
                                break;
                            case ATTR_MODE_FAINT:
                                isFaint = true;
                                break;
                            case ATTR_MODE_UNDERLINE:
                                hasUnderline = true;
                                break;
                            case ATTR_MODE_SLOW_BLINK:
                                isSlowBlink = true;
                                break;
                            // case ATTR_MODE_RAPID_BLINK:
                            //     isRapidBlink = true;
                            //     break;
                            case ATTR_MODE_INVISIBLE:
                                isInvisible = true;
                                break;
                            // case ATTR_MODE_CROSSED_OUT:
                            //     isCrossedOut = true;
                            //     break;
                            default:
                                // if(attrMode > ATTR_MODE_CROSSED_OUT){
                                //     attrMode -= ATTR_MODE_CROSSED_OUT;
                                //     isCrossedOut = true;
                                // }
                                if(attrMode >= ATTR_MODE_INVISIBLE){
                                    attrMode -= ATTR_MODE_INVISIBLE;
                                    isInvisible = true;
                                }
                                // if(attrMode >= ATTR_MODE_RAPID_BLINK){
                                //     attrMode -= ATTR_MODE_RAPID_BLINK;
                                //     isRapidBlink = true;
                                // }
                                if(attrMode >= ATTR_MODE_SLOW_BLINK){
                                    attrMode -= ATTR_MODE_SLOW_BLINK;
                                    isSlowBlink = true;
                                }
                                if(attrMode >= ATTR_MODE_UNDERLINE){
                                    attrMode -= ATTR_MODE_UNDERLINE;
                                    hasUnderline = true;
                                }
                                if(attrMode >= ATTR_MODE_FAINT){
                                    attrMode -= ATTR_MODE_FAINT;
                                    isFaint = true;
                                }
                                if(attrMode >= ATTR_MODE_ITALIC){
                                    attrMode -= ATTR_MODE_ITALIC;
                                    isItalic = true;
                                }
                                if(attrMode >= ATTR_MODE_INVERSE){
                                    attrMode -= ATTR_MODE_INVERSE;
                                    isInverse = true;
                                }
                                if(attrMode >= ATTR_MODE_BOLD){
                                    attrMode -= ATTR_MODE_BOLD;
                                    isBold = true;
                                }
                        }
                        // 解析attr_mode...end...

                        // 加粗和斜体
                        if(isItalic && isBold){
                            current_font_style = DrawFontStyle.BOTH;
                        } else {
                            // 斜体
                            if(isItalic){
                                current_font_style = DrawFontStyle.ITALIC;
                            }
                            // 加粗
                            if(isBold){
                                current_font_style = DrawFontStyle.BOLD;
                            }
                        }

                        if(current_font_style != DrawFontStyle.NORMAL){
                            // 不是正常的字体
                            this.updateTextViewFont(current_font_style);
                        }

                        // 背景颜色。
                        if(!!bgColor){
                            if(this._term.preferences.paletteMap[bgColor])
                                bgColor = this._term.preferences.paletteMap[bgColor];
                        }
                        if(!bgColor) bgColor = this._term.preferences.backgroundColor;

                        // 颜色
                        if(!!color && this._term.preferences.paletteMap[color]) color = this._term.preferences.paletteMap[color];
                        if(!color) color = this._term.preferences.color;

                        if(isInverse){
                            // 颜色反转
                            let tmpColor = color, tmpBgColor = bgColor;
                            if(!!tmpBgColor) color = tmpBgColor;
                            if(!!tmpColor) bgColor = tmpColor;
                        }

                        if(!!bgColor){
                            this.textViewContext.fillStyle = bgColor;
                            this.textViewContext.fillRect(startX, startY, w, height);
                        }

                        if(!!color){
                            this.textViewContext.fillStyle = color;
                        }

                    } else {
                        // 设置默认的字体。
                        if(this.last_font_style != DrawFontStyle.NORMAL){
                            this.updateTextViewFont(DrawFontStyle.NORMAL);
                        }

                        if(this.last_fill_style != this._term.preferences.color){
                            this.textViewContext.fillStyle = this._term.preferences.color;
                        }

                        if(hasUnderline) hasUnderline = false;
                        if(isInvisible) isInvisible = false;
                    }



                    // 画下划线，高度为2个像素
                    // 如果是联想输入，高度为4个像素。
                    if(hasUnderline){
                        let underlineHeight = this._term.preferences.canvasSizeMultiple;
                        this.textViewContext.fillRect(startX, textStartY - underlineHeight, w, underlineHeight);
                    }

                    // 制表符
                    // if(value === "\t"){
                    //     const tabSize = this._term.preferences.tabSize;
                    //     let spCount = tabSize - (charCount % tabSize);
                    //
                    //     for(let i = 0; i < spCount; i++){
                    //         // 空格不输出，只右移。以减少fillText的调用次数
                    //         startX += width;
                    //         charCount += 1;
                    //     }
                    //
                    //     continue;
                    // }

                    // 空格不输出，只右移。以减少fillText的调用次数
                    // 可见 && data != " "
                    if(!isInvisible && blocks_data[x] != " "){
                        // 保存渲染的信息，为了后期可以快速清除。
                        if(render_start == -1) render_start = startX;
                        render_width += w;

                        // 通过测试，一次性渲染多个字符比一个一个字符的渲染慢。
                        this.textViewContext.fillText(blocks_data[x], startX, textStartY);

                    } else {
                        if(render_start >= 0 && render_width != 0){
                            render_info.push(render_start + "," + render_width);
                            // 空格或隐藏的文本。
                            render_start = -1;
                            render_width = 0;
                        }
                    }

                }

                startX += w;
                charCount += displaySize;

                this.last_font_style = current_font_style;
                this.last_fill_style = current_fill_style;

            }

            if(render_start >= 0 && render_width != 0){
                render_info.push(render_start + "," + render_width);
                // 空格或隐藏的文本。
            }

            this.rendered_lines_rect[yIndex] = render_info;

        }

    }

    // hideCursor(){
    //     this._term.cursorView.style.display = "none";
    // }
    //
    // showCursor(){
    //     this._term.cursorView.style.display = "";
    // }









    // /**
    //  * 获取当前行的所有块。
    //  * @param yIndex
    //  */
    // getBlocks(yIndex: number){
    //     return this.activeBuffer.flushedLines[yIndex];
    // }


    select2(selection: CanvasSelection){
        if(!selection.running) return;

        // 清除原来的。
        // 清除画布
        this.clearRect(selection);

        console.info("select2():_csr:" + JSON.stringify(this._csr) + ', last_csr:' + JSON.stringify(this._last_csr));
        console.info("select2:selection: " + JSON.stringify(selection));

        // 当前显示的区域没有选中的文本。
        // 坐标点
        // 选中区域
        // 如 anchorY = 10, focusY = 11
        // minY = 10, maxY = 11
        // selection.offsetTop = 10
        const minY = Math.min(selection.anchorPoint.y, selection.focusPoint.y)
            , maxY = Math.max(selection.anchorPoint.y, selection.focusPoint.y);

        // if(minY == 0 && maxY == 0 && selection.anchorPoint.x == 0 && selection.focusPoint.x == 0) {
        //     console.info("Selection没有选中文本");
        //     return;
        // }

        // 最小行号，最大行号，从1开始
        // minY & maxY = 行号 * height
        const minLineNum = minY / this.height + selection.offsetTop + 1
            , maxLineNum = maxY / this.height + selection.offsetTop + 1;

        // 当前显示的行的开始的行号，从1开始
        const topLineNum = this._csr.top, bottomLineNum = this._csr.bottom;

        console.info("top:" + topLineNum);

        // 选择文本在显示区域下面 || 选择文本在显示区域上面
        // 这两种情况都不用处理。
        if(minLineNum < topLineNum && maxLineNum > bottomLineNum){
            console.info("select: 选中的文本不在显示区域。")
            return;
        }

        // 判断当前的displayLines中是否存在选中区域、
        // selection anchorPoint Y绝对值
        // displayRange Y绝对值

        let startY: number, stopY: number;
        if(topLineNum < minLineNum) {
            startY = minLineNum;
            stopY = bottomLineNum < maxLineNum ? bottomLineNum : maxLineNum;
        } else {
            startY = topLineNum;
            stopY = bottomLineNum < maxLineNum ? bottomLineNum : maxLineNum;
        }

        // startY: 从0开始
        // stopY: 从0开始
        startY -= topLineNum;
        stopY -= topLineNum;

        const width = this._measuredTextWidth
            , fullWidth = this._term.columns * width
            , height = this.height
            , anchorY = startY * height
            , focusY = stopY * height;

        let startX = 0, stopX = 0;
        if(CommonUtils.indexPoint(selection.anchorPoint, selection.focusPoint)){
            // startX第一行从selection.anchorPoint.x开始
            // 其他行从0开始。
            if(topLineNum <= minLineNum) {
                startX = selection.anchorPoint.x;
            }
            // 最后一行为0
            // 其他行为selection.focusPoint.x
            if(bottomLineNum < maxLineNum){
                stopX = fullWidth;
            } else {
                stopX = selection.focusPoint.x;
            }
        } else if(CommonUtils.reverseIndexPoint(selection.anchorPoint, selection.focusPoint)){
            if(topLineNum <= minLineNum) {
                startX = selection.focusPoint.x;
            }
            // 最后一行为0
            // 其他行为selection.focusPoint.x
            if(bottomLineNum < maxLineNum){
                stopX = fullWidth;
            } else {
                stopX = selection.anchorPoint.x;
            }
        }

        const anchorX = startX, focusX = stopX;

        // 临时保存selection.ranges
        let ranges = selection.ranges;
        selection.clearRanges();

        for(let y = anchorY,
                x = 0,
                w = 0,
                yIndex = 0,
                startIndex = 0,
                stopIndex = -1,
                i = 0; y <= focusY; y+=height, i++){
            if(y == anchorY) {

                if(y == focusY){
                    // 全部在一行
                    startIndex = Math.floor(anchorX / width);
                    stopIndex = Math.floor(focusX / width);
                    w = focusX - anchorX;       // 考虑占两个位置的emoji表情
                } else {
                    // 第一行
                    startIndex = Math.floor(anchorX / width);
                    stopIndex = -1;
                    w = fullWidth - anchorX;
                }
                x = anchorX;
            } else if(y == focusY){
                // 最后一行
                x = 0;
                w = focusX;     // 考虑占两个位置的emoji表情
                startIndex = 0;
                stopIndex = Math.floor(focusX / width);
            } else {
                // 中间行
                x = 0;
                w = fullWidth;
                startIndex = 0;
                stopIndex = -1;
            }

            // if(ranges[i]
            //     && CommonUtils.isSamePoint(ranges[i].startPoint, new SelectionPoint(x, y))
            //     && CommonUtils.isSamePoint(ranges[i].stopPoint, new SelectionPoint(w + x, y))){
            //     // console.info("第" + (i + 1) + "行不用渲染");
            //     selection.ranges[i] = ranges[i];
            //     continue;
            // }

            // [0, this._term.rows - 1]
            yIndex = Math.floor(y / height);
            // console.info("yIndex:" + yIndex + ", startIndex:" + startIndex + ", stopIndex:" + stopIndex);

            let data_arr = this.activeBuffer.window_buf.lines[yIndex];
            // yIndex最大值：this._term.rows - 1
            if(yIndex > this._term.rows - 1){
                // []
                continue;
            }

            let selectedTextArray;
            if(stopIndex == -1){
                selectedTextArray = data_arr.slice(startIndex, data_arr.length);
            } else {
                selectedTextArray = data_arr.slice(startIndex, stopIndex);
            }

            // console.info(blocks);
            // console.info(selectedBlocks);

            // 清除当前行
            // this.clearLine(yIndex + 1);
            // if(this.selectionViewContext){
            //     this.selectionViewContext.clearRect(w + x, y, fullWidth, this.height);
            // }

            // 如果第一行是空行的话，不用选中。
            let selectedContent = this.handleSelectedContent(selectedTextArray);
            // let textLength = selectedTextArray.length;
            // if(y == anchorY && textLength == 0){
            //     selection.ranges[i] = new SelectionRange(0, 0, 0, 0, "", 0);
            //     continue;
            // }


            // console.info("selectedTextArray.length=" + selectedTextArray.length + ", focusX=" + (focusX / width));

            // 如果focusX大于当前行的文本的坐标值的话，当前行全选。
            // if(y == focusY){
            //     if(textLength < Math.floor((focusX / width))){
            //         w = fullWidth;
            //     }
            // }
            this.drawSelectedText(x, y, height, width);
            selection.ranges[i] = new SelectionRange(x, y, w + x, y, selectedContent.join(""));

        }

        // 判断哪行是多余的（被取消选中的）
        // selection.ranges 和 ranges做对比
        // if(selection.ranges.length < ranges.length){
        //     // 取消选中的行应该是ranges.length - selection.ranges.length
        //     for(let i = selection.ranges.length, len = ranges.length; i < len; i++){
        //         if(this.selectionViewContext){
        //             this.selectionViewContext.clearRect(ranges[i].startPoint.x,
        //                 ranges[i].startPoint.y, ranges[i].stopPoint.x - ranges[i].startPoint.x, this.height);
        //         }
        //     }
        // }



    }

    /**
     * 内容选择
     * @param selection
     */
    select(selection: CanvasSelection) {
        // console.info(JSON.stringify(selection));
        if(this.selectionViewContext){

            const width = this._measuredTextWidth
                , height = this.height
                , fullWidth = this._term.columns * width;

            // console.info("fullWidth:" + fullWidth);
            // 开始坐标(x, y)
            // 结束坐标(x, y)
            const anchorX = selection.anchorPoint.x
                , anchorY = selection.anchorPoint.y
                ,  focusX = selection.focusPoint.x
                ,  focusY = selection.focusPoint.y;

            // let anchorPoint = new SelectionPoint(anchorX, anchorY),
            //     focusPoint = new SelectionPoint(focusX, focusY);

            // 判断两个点是否相同
            // console.info("判断两个点是否相同：" + (this.lastAnchorPoint.x == anchorX
            //     && this.lastAnchorPoint.y == anchorY
            //     && this.lastFocusPoint.x == focusX
            //     && this.lastFocusPoint.y == focusY));
            // console.info(JSON.stringify(this.lastAnchorPoint) + JSON.stringify(this.lastFocusPoint));
            // console.info("anchorY：" + anchorY + "， anchorX：" + anchorX + "，focusX：" + focusX + "，focusY：" + focusY);
            //
            if(CommonUtils.isSamePoint(this.lastAnchorPoint, selection.anchorPoint)
                && CommonUtils.isSamePoint(this.lastFocusPoint, selection.focusPoint)){
                // 位置相同，不用处理。
                console.info("位置相同，不用处理。");
                return;
            }
            //

            // 上次选择的点
            if(CommonUtils.indexPoint(selection.anchorPoint, selection.focusPoint)){
                // 正向选择
                // 从上往下选择。
                // console.info("正向选择。。。");
                if(this.isReverseSelect){
                    // 首先需要取消之前选中的。如果之前是反向选择的话。
                    this.unselect(selection);
                }
                this.isReverseSelect = false;

                // 临时保存selection.ranges
                let ranges = selection.ranges;
                selection.clearRanges();

                for(let y = anchorY,
                        x = 0,
                        w = 0,
                        yIndex = 0,
                        startIndex = 0,
                        stopIndex = -1,
                        i = 0; y <= focusY; y+=height, i++){
                    if(y == anchorY) {

                        if(y == focusY){
                            // 全部在一行
                            startIndex = Math.floor(anchorX / width);
                            stopIndex = Math.floor(focusX / width);
                            w = focusX - anchorX;       // 考虑占两个位置的emoji表情
                        } else {
                            // 第一行
                            startIndex = Math.floor(anchorX / width);
                            stopIndex = -1;
                            w = fullWidth - anchorX;
                        }
                        x = anchorX;
                    } else if(y == focusY){
                        // 最后一行
                        x = 0;
                        w = focusX;     // 考虑占两个位置的emoji表情
                        startIndex = 0;
                        stopIndex = Math.floor(focusX / width);
                    } else {
                        // 中间行
                        x = 0;
                        w = fullWidth;
                        startIndex = 0;
                        stopIndex = -1;
                    }

                    if(ranges[i]
                        && CommonUtils.isSamePoint(ranges[i].startPoint, new SelectionPoint(x, y))
                        && CommonUtils.isSamePoint(ranges[i].stopPoint, new SelectionPoint(w + x, y))){
                        // console.info("第" + (i + 1) + "行不用渲染");
                        selection.ranges[i] = ranges[i];
                        continue;
                    }

                    // [0, this._term.rows - 1]
                    yIndex = Math.floor(y / height);
                    // console.info("yIndex:" + yIndex + ", startIndex:" + startIndex + ", stopIndex:" + stopIndex);

                    let data_arr = this.activeBuffer.window_buf.lines[yIndex];
                    // yIndex最大值：this._term.rows - 1
                    if(yIndex > this._term.rows - 1){
                        // []
                        continue;
                    }

                    let selectTextArray;
                    if(stopIndex == -1){
                        selectTextArray = data_arr.slice(startIndex, data_arr.length);
                    } else {
                        selectTextArray = data_arr.slice(startIndex, stopIndex);
                    }

                    // console.info(blocks);
                    // console.info(selectedBlocks);

                    // 清除当前行
                    // this.clearLine(yIndex + 1);
                    if(this.selectionViewContext){
                        this.selectionViewContext.clearRect(w + x, y, fullWidth, this.height);
                    }

                    // 如果第一行是空行的话，不用选中。
                    let selectedContent = this.handleSelectedContent(selectTextArray);

                    let textLength = selectedContent.length;
                    if(y == anchorY && textLength == 0){
                        selection.ranges[i] = new SelectionRange(0, 0, 0, 0, "");
                        continue;
                    }

                    // 考虑中文占位符的问题
                    if(textLength > 0){
                        if(selectedContent[0] === ""){
                            // 中文占位符
                            if(stopIndex == -1){
                                selectTextArray = data_arr.slice(startIndex + 1, data_arr.length);
                            } else {
                                selectTextArray = data_arr.slice(startIndex + 1, stopIndex);
                            }

                            w = w - width;
                            x = x + width;
                        }
                    }

                    // console.info("selectedTextArray.length=" + selectedTextArray.length + ", focusX=" + (focusX / width));

                    // 如果focusX大于当前行的文本的坐标值的话，当前行全选。
                    // if(y == focusY){
                    //     if(textLength < Math.floor((focusX / width))){
                    //         w = fullWidth;
                    //     }
                    // }
                    this.drawSelectedText(x, y, height, width);
                    selection.ranges[i] = new SelectionRange(x, y, w + x, y, selectedContent.join(""));

                }

                // 判断哪行是多余的（被取消选中的）
                // selection.ranges 和 ranges做对比
                if(selection.ranges.length < ranges.length){
                    // 取消选中的行应该是ranges.length - selection.ranges.length
                    for(let i = selection.ranges.length, len = ranges.length; i < len; i++){
                        if(this.selectionViewContext){
                            this.selectionViewContext.clearRect(ranges[i].startPoint.x,
                                ranges[i].startPoint.y, ranges[i].stopPoint.x - ranges[i].startPoint.x, this.height);
                        }
                    }
                }

                // console.info(selection.ranges);



            } else if(CommonUtils.reverseIndexPoint(selection.anchorPoint, selection.focusPoint)){
                // 反向选择
                // 从下往上选择
                if(!this.isReverseSelect){
                    // 首先需要取消之前选中的。如果之前是正选选择的话。
                    this.unselect(selection);
                }

                this.isReverseSelect = true;

                // console.info("反向选择");
                //
                // 临时保存selection.ranges
                let ranges = selection.ranges;
                selection.clearRanges();

                // console.info("len=" + Math.floor((anchorY - focusY) / height) + ", anchorY=" + anchorY + ", focusY=" + focusY + ", height=" + height);

                // 反向遍历。
                for(let y = 0,
                        x = 0,
                        w = 0,
                        i = 0,
                        // len = Math.floor((anchorY - focusY) / height),
                        startIndex = 0,
                        stopIndex = 0; y <= anchorY; y += height, i++){

                    if(y < focusY){
                        // console.info("y=" + y);
                        selection.ranges[i] = new SelectionRange(0, y, 0, y, "", true);

                        // 清除当前行
                        if(!ranges[i] || (ranges[i].startPoint.x == 0 && ranges[i].stopPoint.x == 0)){
                            // 两个点为原点。
                            // startPointX == stopPointX
                            continue
                        } else {
                            // 如果不是的话，则清掉
                            if(this.selectionViewContext){
                                this.selectionViewContext.clearRect(0, y, fullWidth, this.height);
                            }
                        }
                        continue;
                    }

                    if(y == focusY) {
                        if(y == anchorY){
                            // 全部在一行
                            startIndex = Math.floor(focusX / width);
                            stopIndex = Math.floor(anchorX / width);
                            w = anchorX - focusX;   // 需要渲染的宽度
                        } else {
                            // 第一行
                            startIndex = Math.floor(focusX / width);
                            stopIndex = -1;
                            w = fullWidth - focusX; // 需要渲染的宽度
                        }
                        x = focusX;

                        // 第一行取消选中
                        // 如果不是的话，则清掉
                        if(this.selectionViewContext){
                            this.selectionViewContext.clearRect(0, y, x, this.height);
                        }

                    } else if(y == anchorY){
                        // 最后一行
                        x = 0;
                        w = anchorX;    // 需要渲染的宽度
                        startIndex = 0;
                        stopIndex = Math.floor(anchorX / width);
                    } else {
                        // 中间行
                        x = 0;
                        w = fullWidth;  // 需要渲染的宽度
                        startIndex = 0;
                        stopIndex = -1;
                    }

                    // console.info("selection=" + JSON.stringify(selection));

                    // 判断哪行不用重新渲染。
                    // 从底部开始。
                    if(ranges[i]
                        && CommonUtils.isSamePoint(ranges[i].startPoint, new SelectionPoint(x, y))
                        && CommonUtils.isSamePoint(ranges[i].stopPoint, new SelectionPoint(w + x, y))){
                        // console.info("第" + (i + 1) + "行不用渲染");
                        selection.ranges[i] = ranges[i];
                        continue;
                    }


                    // [0, this._term.rows - 1]
                    // console.info("i:" + i + ", startIndex:" + startIndex + ", stopIndex:" + stopIndex);

                    let data_arr = this.activeBuffer.window_buf.lines[i];
                    // yIndex最大值：this._term.rows - 1
                    if(i > this._term.rows - 1){
                        // []
                        continue;
                    }

                    let selectTextArray;
                    if(stopIndex == -1){
                        selectTextArray = data_arr.slice(startIndex, data_arr.length);
                    } else {
                        selectTextArray = data_arr.slice(startIndex, stopIndex);
                    }

                    // 获取选中的内容
                    let selectedContent = this.handleSelectedContent(selectTextArray);
                    if(selectedContent.length > 0){
                        if(selectedContent[0] === ""){
                            // 中文占位符
                            if(stopIndex == -1){
                                selectTextArray = data_arr.slice(startIndex - 1, data_arr.length);
                            } else {
                                selectTextArray = data_arr.slice(startIndex - 1, stopIndex);
                            }

                            w = w + width;
                            x = x - width;
                        }
                    }

                    // console.info("selectedBlocks:" + JSON.stringify(selectedBlocks));

                    this.drawSelectedText(x, y, height, width);
                    selection.ranges[i] = new SelectionRange(x, y, w + x, y, selectedContent.join(""));

                }


            } else {
                // 两个点相同。
                // console.info("两个点相同。");
            }

            selection.running = true;

            this.lastAnchorPoint = selection.anchorPoint;
            this.lastFocusPoint = selection.focusPoint;

            this._term.clipboard.value = selection.selectedContent;
            this._term.clipboard.select();

            console.info("select:selectedContent:\"" + selection.selectedContent + "\"");

        }

    }

    /**
     * 处理选中的内容，如果后面全部都是空格的话，就不用返回空格，只返回空行。
     * @param selectTextArray
     */
    handleSelectedContent(selectTextArray: string[]){
        let validIndex = -1, result = [];
        for(let i = 0, len = selectTextArray.length; i < len; i++){
            if(selectTextArray[i] != " "){
                validIndex = i;
            }
            result[i] = selectTextArray[i];
        }
        if(validIndex == -1){
            return [];
        }
        return result.slice(0, validIndex + 1);
    }

    /**
     * 绘制选中的文字
     * @param startX
     * @param startY
     // * @param selectedWidth 选中区域的宽度
     * @param height 当前行的高度
     * @param charWidth 字符宽度
     */
    drawSelectedText(startX: number
                     , startY: number
                     // , selectedWidth: number
                     , height: number
                     , charWidth: number): void{
        // 渲染选中颜色。
        if(this.selectionViewContext){

            // 计算从第几个字符开始
            let charCount = startX / charWidth
                , textStartY = startY + height
                , yIndex = startY / height
                , xIndex = charCount
                , blocks_data = this.activeBuffer.window_buf.lines[yIndex]    // 数据
                , blocks_attr = this.activeBuffer.window_buf.line_attrs[yIndex]   // 属性
                , blocks_char_width = this.activeBuffer.window_buf.line_char_widths[yIndex]   //
                , blocks_color = this.activeBuffer.window_buf.line_colors[yIndex]
                , blocks_bg_color = this.activeBuffer.window_buf.line_bg_colors[yIndex];

            for (let x = xIndex
                     , len = blocks_data.length
                     , current_font_style: DrawFontStyle = DrawFontStyle.NORMAL
                     , hasUnderline // 是否含有下划线
                     , isInvisible  // 是否含有下划线
                     , isBold = false
                     , isInverse = false
                     , isFaint = false
                     , isItalic = false
                     , isSlowBlink = false
                     // , isRapidBlink = false
                     // , isCrossedOut = false
                     , attrMode; x <= len; x++) {


                // 空块
                if (!blocks_data[x] || blocks_data[x].length == 0) continue;

                // let value = block.data;
                // let invisible = block.isInvisible, underline = block.isUnderline;
                let selectionColor;
                let selectionTextColor;

                if((attrMode = blocks_attr[x]) != ATTR_MODE_NONE){
                    // 没有渲染的块
                    // 解析样式
                    // let array = DataBlockAttribute.parseClassName(CommonUtils.substring(block, 2));
                    // let className = array[0];
                    let color = blocks_color[x], bgColor = blocks_bg_color[x];

                    if(isBold) isBold = false;
                    if(isInverse) isInverse = false;
                    if(isItalic) isItalic = false;
                    if(isFaint) isFaint = false;
                    if(isFaint) isFaint = false;
                    if(hasUnderline) hasUnderline = false;
                    if(isSlowBlink) isSlowBlink = false;
                    // if(isRapidBlink) isRapidBlink = false;
                    if(isInvisible) isInvisible = false;
                    // if(isCrossedOut) isCrossedOut = false;

                    // 解析attr_mode...
                    switch (attrMode) {
                        case ATTR_MODE_NONE:
                            break;
                        case ATTR_MODE_BOLD:
                            isBold = true;
                            break;
                        case ATTR_MODE_INVERSE:
                            isInverse = true;
                            break;
                        case ATTR_MODE_ITALIC:
                            isItalic = true;
                            break;
                        case ATTR_MODE_FAINT:
                            isFaint = true;
                            break;
                        case ATTR_MODE_UNDERLINE:
                            hasUnderline = true;
                            break;
                        case ATTR_MODE_SLOW_BLINK:
                            isSlowBlink = true;
                            break;
                        // case ATTR_MODE_RAPID_BLINK:
                        //     isRapidBlink = true;
                        //     break;
                        case ATTR_MODE_INVISIBLE:
                            isInvisible = true;
                            break;
                        // case ATTR_MODE_CROSSED_OUT:
                        //     isCrossedOut = true;
                        //     break;
                        default:
                            // if(attrMode > ATTR_MODE_CROSSED_OUT){
                            //     attrMode -= ATTR_MODE_CROSSED_OUT;
                            //     isCrossedOut = true;
                            // }
                            if(attrMode >= ATTR_MODE_INVISIBLE){
                                attrMode -= ATTR_MODE_INVISIBLE;
                                isInvisible = true;
                            }
                            // if(attrMode >= ATTR_MODE_RAPID_BLINK){
                            //     attrMode -= ATTR_MODE_RAPID_BLINK;
                            //     isRapidBlink = true;
                            // }
                            if(attrMode >= ATTR_MODE_SLOW_BLINK){
                                attrMode -= ATTR_MODE_SLOW_BLINK;
                                isSlowBlink = true;
                            }
                            if(attrMode >= ATTR_MODE_UNDERLINE){
                                attrMode -= ATTR_MODE_UNDERLINE;
                                hasUnderline = true;
                            }
                            if(attrMode >= ATTR_MODE_FAINT){
                                attrMode -= ATTR_MODE_FAINT;
                                isFaint = true;
                            }
                            if(attrMode >= ATTR_MODE_ITALIC){
                                attrMode -= ATTR_MODE_ITALIC;
                                isItalic = true;
                            }
                            if(attrMode >= ATTR_MODE_INVERSE){
                                attrMode -= ATTR_MODE_INVERSE;
                                isInverse = true;
                            }
                            if(attrMode >= ATTR_MODE_BOLD){
                                attrMode -= ATTR_MODE_BOLD;
                                isBold = true;
                            }
                    }
                    // 解析attr_mode...end...

                    // 加粗和斜体
                    if(isItalic && isBold){
                        current_font_style = DrawFontStyle.BOTH;
                    } else {
                        // 斜体
                        if(isItalic){
                            current_font_style = DrawFontStyle.ITALIC;
                        }
                        // 加粗
                        if(isBold){
                            current_font_style = DrawFontStyle.BOLD;
                        }
                    }

                    if(current_font_style != DrawFontStyle.NORMAL){
                        // 不是正常的字体
                        this.updateSelectionViewFont(current_font_style);
                    }

                    // console.info("className:" + className + ", color:" + color + ', bgColor:' + bgColor);

                    // 字体斜体，字体加粗

                    // this.selectionViewContext.font = this.getFont(block.isItalic, block.isBold);

                    // 绘制选中的背景颜色。
                    if(this._term.preferences.selectionColor.length > 0){
                        selectionColor = this._term.preferences.selectionColor;
                    } else {

                        if(isInverse){
                            // 颜色反转
                            selectionColor = this._term.preferences.backgroundColor;
                        } else {

                            if(!!color && this._term.preferences.paletteMap[color]){
                                selectionColor = this._term.preferences.paletteMap[color];
                            } else {
                                // 默认颜色。
                                selectionColor = this._term.preferences.color;
                            }

                        }


                    }

                    // 设置选中的颜色。
                    this.selectionViewContext.fillStyle = selectionColor;
                    this.selectionViewContext.fillRect(startX, startY, charWidth * blocks_char_width[x], this.height);

                    // 绘制选中的文本颜色。
                    if(this._term.preferences.selectionTextColor.length > 0){
                        selectionTextColor = this._term.preferences.selectionTextColor;
                    } else {
                        if(isInverse){
                            // 颜色反转
                            selectionTextColor = this._term.preferences.color;
                        } else {
                            selectionTextColor = (!!bgColor && this._term.preferences.paletteMap[bgColor]) ?
                                this._term.preferences.paletteMap[bgColor]: this._term.preferences.backgroundColor;
                        }


                    }

                    this.selectionViewContext.fillStyle = selectionTextColor;

                } else {
                    // 设置默认的字体。
                    // 设置默认的字体。
                    this.updateSelectionViewFont(DrawFontStyle.NORMAL);

                    selectionColor = this._term.preferences.selectionColor.length > 0 ? this._term.preferences.selectionColor: this._term.preferences.color;
                    selectionTextColor = this._term.preferences.selectionTextColor.length > 0 ? this._term.preferences.selectionTextColor : this._term.preferences.backgroundColor;

                    this.selectionViewContext.fillStyle = selectionColor;
                    this.selectionViewContext.fillRect(startX, startY, charWidth * blocks_char_width[x], this.height);
                    this.selectionViewContext.fillStyle = selectionTextColor;

                }

                // 画下划线，高度为2个像素
                // 制表符
                // if(value === "\t"){
                //     const tabSize = this._term.preferences.tabSize;
                //     let spCount = tabSize - (charCount % tabSize);
                //
                //     for(let i = 0; i < spCount; i++){
                //         // 空格不输出，只右移。以减少fillText的调用次数
                //         this.selectionViewContext.fillStyle = selectionColor;
                //         this.selectionViewContext.fillRect(startX, startY, charWidth, this.height);
                //         startX += charWidth;
                //         charCount += 1;
                //     }
                //
                //     continue;
                // }

                // 空格不输出，只右移。以减少fillText的调用次数
                if(!isInvisible && blocks_data[x] != " "){
                    this.selectionViewContext.fillText(blocks_data[x], startX, textStartY);
                }

                startX += charWidth * blocks_char_width[x];
                charCount += blocks_char_width[x];

                // drawCursor
                // if(this.activeBuffer.x == x + 1 && this.activeBuffer.y == y + 1){
                //     console.info("绘制光标..");
                //     this.drawCursor(false, selectionColor, selectionTextColor);
                // }

            }

            // return startX;

        }

        // return startX + selectedWidth;

    }

    /**
     * 仅清除画布
     * @param selection
     */
    clearRect(selection: CanvasSelection){
        if(this.selectionViewContext) {
            if(/*selection.ranges.length == 0 || */selection.selectAll){
                this.selectionViewContext.clearRect(0,
                    0, this._term.selectionView.width, this._term.selectionView.height);
                return;
            } else {
                for(let range of selection.ranges){
                    // 获取所有选中的范围。
                    this.selectionViewContext.clearRect(range.startPoint.x,
                        range.startPoint.y, range.realStopX - range.startPoint.x, this.height);
                }
            }
        }
    }

    /**
     * 取消选择。
     */
    unselect(selection: CanvasSelection){

        if(!selection.running) return;

        if(this.selectionViewContext){

            console.info(selection);
            // 清除画布
            this.clearRect(selection);

            selection.clearRanges();
            selection.running = false;

            // 取消选中、
            let sel = window.getSelection();
            if(sel){
                sel.removeAllRanges();
            }
            this._term.clipboard.value = "";
        }
    }


    /**
     * 处理块选择
     * @param index
     * @param blocks
     * @param flag
     */
    private handleSelectBlock(index: number, blocks: string[], flag: number): number{

        let chr = blocks[index];
        if(flag == 1) {
            if(CommonUtils.isNumberLetter(chr)) {
                return index;
            } else {
                return -1;
            }
        } else if(flag == 2) {
            if(CommonUtils.isSymbol(chr)) {
                return index;
            } else {
                return -1;
            }
        } else if(flag == 3) {
            if(CommonUtils.isChinese(chr)
                || (chr == "" && CommonUtils.isChinese(blocks[index - 1]))) {
                // 中文或下一个是中文的占位号
                return index;
            } else {
                return -1;
            }
        } else if(flag == 4) {
            if(CommonUtils.isChineseSymbol(chr)
                || (chr == "" && CommonUtils.isChineseSymbol(blocks[index - 1]))) {
                // 中文或下一个是中文的占位号
                return index;
            } else {
                return -1;
            }
        } else if(flag == 10){
            // 左边的字符需要对应右边的字符
            if(/[)}\]>）】」》]/gi.test(chr)){
                return index;
            } else {
                return -1;
            }
        } else if(flag == 11){
            // 右边的字符需要对应左边的字符。
            if(/[({\[<（【「《]/gi.test(chr)){
                return index;
            } else {
                return -1;
            }
        }
        return -1;
    }

    /**
     * 选中块，主要是当前行，双击
     * 1，字母的话，选中前后的字母。
     * 2，特殊字符的话，选中前后的特殊字符
     * 3，中文的话，选中前后的中文
     * @param selection
     */
    selectBlock(selection: CanvasSelection) {

        if(this.selectionViewContext){


            const width = this._measuredTextWidth
                , height = this.height
                // selection.anchorPoint.y = index * height，需要索引的话，需要除height
                , startYIndex = Math.floor(selection.anchorPoint.y / height)
                , blocks = this.activeBuffer.window_buf.lines[startYIndex];

            let startXIndex = Math.floor(selection.anchorPoint.x / width);
            let selectedChar = blocks[startXIndex];

            if(selectedChar == ""){
                // 内存存储结构：["a", "b", "c", "中", "", "文", ""]
                // 计算到当前是中文占位符
                // 获取上一个中文
                startXIndex -= 1;
                selectedChar = blocks[startXIndex];
            }

            let flag = 0;
            if(CommonUtils.isNumberLetter(selectedChar)) {
                // 数字 + 字母
                flag = 1;
            } else if(/[({\[<（【「《]/gi.test(selectedChar)){
                // 整对的特殊字符(左): (){}[]<>（）【】「」《》
                flag = 10;
            } else if(/[)}\]>）】」》]/gi.test(selectedChar)){
                // 整对的特殊字符(右): (){}[]<>（）【】「」《》
                flag = 11;
            } else if(CommonUtils.isSymbol(selectedChar)){
                // 符号
                flag = 2;
            } else if(CommonUtils.isChinese(selectedChar)){
                // 中文
                flag = 3;
            } else if(CommonUtils.isChineseSymbol(selectedChar)){
                // 中文符号
                flag = 4;
            }

            // 左边搜索
            let leftIndex = startXIndex;
            if(flag != 10){
                // 如果是特殊字符，左边的符号
                let ret_index = leftIndex;
                for(let i = startXIndex - 1; 0 <= i; i--){
                    ret_index = this.handleSelectBlock(i, blocks, flag);
                    if(flag == 11){
                        // 右边特殊字符，如)、>、}等。
                        if(ret_index == -1) continue;
                        break;
                    }
                    if(ret_index == -1) break;
                    leftIndex = ret_index;
                }
                // 处理特殊字符
                if(ret_index != -1) leftIndex = ret_index;
            }

            // 右边搜索
            let rightIndex = startXIndex;
            if(flag != 11){
                let ret_index = rightIndex;
                for(let i = startXIndex + 1, len = blocks.length; i < len; i++){
                    ret_index = this.handleSelectBlock(i, blocks, flag);
                    if(flag == 10){
                        // 左边特殊字符，如(、<、{等。
                        if(ret_index == -1) continue;
                        break;
                    }
                    if(ret_index == -1) break;
                    rightIndex = ret_index;
                }
                // 处理特殊字符
                if(ret_index != -1) rightIndex = ret_index;
            }

            console.info("leftIndex:" + leftIndex + ", rightIndex:" + rightIndex);

            const selectedContent = blocks.slice(leftIndex, rightIndex + 1);
            const x = leftIndex * width
                , y = startYIndex * height
                , w = (rightIndex - leftIndex + 1) * width;

            console.info("x:" + x + ", y:" + y + ", w:" + w + ", height:" + height);

            // 绘制选中的颜色
            selection.clearRanges();
            // 正常的，stopX = x + w, 但是如果出现中文等字符的话，一个中文 = width * 2;
            this.drawSelectedText(x, y, height, width);
            selection.running = true;

            // 解析选中的文本
            let selectedText = this.handleSelectedContent(selectedContent).join("");
            selection.ranges.push(new SelectionRange(x, y, x + w, y, selectedText));

            this._term.clipboard.value = selection.selectedContent;
            this._term.clipboard.select();

            console.info("selectedContent:" + selection.selectedContent);

            console.info(JSON.stringify(selection));

            // 更新selection
            // 考虑后面会滚动，滚动调用select方法渲染
            selection.start(x, y, this._term.getOffsetTop());
            selection.stop(x + w, y);

            console.info(JSON.stringify(selection));

            // 22019aaaa-aaa

        }

    }


    /**
     * 选中一整行，三击
     * @param selection
     */
    selectLine(selection: CanvasSelection){

        if(this.selectionViewContext){

            const height = this.height
                , width = this._measuredTextWidth
                , fullWidth = this._term.columns * width
                // selection.anchorPoint.y = index * height，需要索引的话，需要除height
                , startY = selection.anchorPoint.y
                , startYIndex = Math.floor(startY / height)
                , selectedContent = this.activeBuffer.window_buf.lines[startYIndex];

            // 绘制选中的颜色
            selection.clearRanges();
            this.drawSelectedText(0, startY, height, width);
            selection.running = true;
            // 解析选中的文本
            const selectedText = this.handleSelectedContent(selectedContent).join("");
            selection.ranges.push(new SelectionRange(0, startY, fullWidth, startY, selectedText));

            // 更新selection
            // 考虑后面会滚动，滚动调用select方法渲染
            selection.start(0, startY, this._term.getOffsetTop());
            selection.stop(fullWidth, startY);

            this._term.clipboard.value = selection.selectedContent;
            this._term.clipboard.select();

            console.info("selectedContent:" + selection.selectedContent);

        }
    }

    /**
     * 全选
     * @param selection
     */
    selectAll(selection: CanvasSelection) {

        if(this.selectionViewContext){

            const width = this._measuredTextWidth
                , height = this.height
                , fullWidth = this._term.columns * width
                , saved_lines = this._term.bufferSet.normal.saved_buf.lines;

            const lineCount = saved_lines.length + this.activeBuffer.size;

            if(lineCount != selection.ranges.length){
                // 选中其他区域，需要清掉
                selection.clearRanges();

                // 这块是滚动区保存的行。
                for(const blocks of saved_lines){
                    if(!blocks) continue;
                    // 解析选中的文本
                    const selectedText = this.handleSelectedContent(blocks).join("");
                    selection.ranges.push(new SelectionRange(0, 0, 0, 0, selectedText));
                }

                // 这块是缓冲区的行
                for(const blocks of this.activeBuffer.change_buf.lines){
                    if(!blocks) continue;
                    // 解析选中的文本
                    const selectedText = this.handleSelectedContent(blocks).join("");
                    selection.ranges.push(new SelectionRange(0, 0, 0, 0, selectedText));
                }
            }

            this.clearRect(selection);

            // 渲染显示内容
            for(let y = 0, len = this.activeBuffer.size; y < len; y++){
                this.drawSelectedText(0, y * height, height, width);
            }

            selection.running = true;
            selection.selectAll = true;

            this._term.clipboard.value = selection.selectedContent;
            this._term.clipboard.select();
        }


    }


    /**
     * 处理窗口缩放，滚动时候的选中内容。
     */
    handleSelect(): number{

        // 什么都没有选中
        if(!this._term.selection.running){
            return 0;
        }

        // 全选。
        // 全选的时候，不用渲染内容。
        if(this._term.selection.selectAll){
            this.selectAll(this._term.selection);
            return 1;
        } else {
            // 部分选中
            this.select2(this._term.selection);
            return 2;
        }
    }

}